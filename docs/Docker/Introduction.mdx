---
title: Introduction to Docker
tags:
   - Docker
   - Docker Compose
   - Tutorial
keywords: [Docker, Docker Engine, Tutorial]
last_update:
  author: BankaiTech
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Docker: An Essential Tool for Developers

Docker is a powerful platform that enables developers to build, share, and run applications with ease. By using Docker, you can ensure that your applications run in an isolated environment called a container, which bundles the application's code, libraries, and dependencies in a single package.

## What is Docker?

Docker is an open-source project that automates the deployment of applications inside software containers. These containers can be thought of as lightweight, portable, and self-sufficient systems that are able to run any application, on any computing environment, without the overhead of traditional virtual machines. Docker utilizes resource isolation features of the Linux kernel such as cgroups and namespace to allow independent "containers" to run within a single Linux instance, avoiding the overhead of starting and maintaining virtual machines.

## Key Features of Docker

- **Containerization**: Docker packages applications and their dependencies into a compact, portable container that can run anywhere, ensuring consistency across environments.
- **Microservices Architecture Support**: It simplifies the development and deployment of microservices by allowing each service to run in its own container.
- **Isolation**: Containers are isolated from each other and the host system, providing a secure environment for applications.
- **Scalability**: Easily scale up or down with minimal setup required, making it ideal for applications with fluctuating demand.
- **Efficiency**: Docker enables more efficient use of system resources compared to traditional virtual machines, as containers share the host system's kernel rather than requiring their own operating system.

## Uses of Docker

<Tabs
  defaultValue="development"
  values={[
    {label: 'Development', value: 'development'},
    {label: 'Testing', value: 'testing'},
    {label: 'CI/CD', value: 'ci_cd'},
    {label: 'Deployment', value: 'deployment'},
  ]}>
  <TabItem value="development">
    Docker streamlines the development process by creating a consistent environment for all team members. It eliminates the "it works on my machine" problem by ensuring that the development environment matches production.
  </TabItem>
  <TabItem value="testing">
    Testing in Docker containers ensures that tests run in the same environment where the applications are developed and deployed, leading to more reliable testing outcomes.
  </TabItem>
  <TabItem value="ci_cd">
    Docker integrates seamlessly into CI/CD pipelines, allowing for the automated building, testing, and deployment of applications with Docker containers.
  </TabItem>
  <TabItem value="deployment">
    Docker simplifies deployment by allowing applications to be deployed in containers, which can be easily moved to different environments, scaled, and managed.
  </TabItem>
</Tabs>

<Tabs
  defaultValue="docker_engine"
  values={[
    {label: 'Docker Engine', value: 'docker_engine'},
    {label: 'Docker Compose', value: 'docker_compose'},
  ]}>
  <TabItem value="docker_engine">
    Docker Engine is the core of Docker, providing the runtime environment for containers. It allows users to build and containerize applications, then run them as isolated containers. This lightweight and powerful engine supports container orchestration, networking, volume management, and more, making it the backbone of the Docker platform.
  </TabItem>
  <TabItem value="docker_compose">
    Docker Compose is a tool for defining and running multi-container Docker applications. With Compose, you can use a YAML file to configure your applicationÃ¢â‚¬â„¢s services, networks, and volumes, and then create and start all the services from your configuration with a single command. It simplifies the development process by allowing developers to define a complex stack in a file, then manage it with simple commands.
  </TabItem>
</Tabs>

## Docker Images

A **Docker image** is a lightweight, standalone, executable package that includes everything needed to run a piece of software, including the code, a runtime, libraries, environment variables, and config files. Images are the building blocks of Docker containers. An image is essentially a snapshot of an application and its environment at a specific point in time.

### Benefits:
- **Consistency:** Ensures that your application runs the same way in development, testing, and production.
- **Portability:** Can be shared across different machines, eliminating the "it works on my machine" problem.
- **Version Control:** You can version images, roll back to previous versions, and manage them just like source code.

## Docker Containers

A **Docker container** is a runnable instance of an image. You can think of it as the execution environment for your application. Containers isolate your application from the host system and other containers, providing a private space for the application to run within.

### Benefits:
- **Isolation:** Prevents conflicts between applications or between applications and the host system.
- **Resource Efficiency:** Containers share the host systemâ€™s kernel but can be limited to specific amounts of CPU, memory, and I/O.
- **Scalability:** Containers can be easily started, stopped, and replicated, which supports modern agile and DevOps practices.

## Docker Environment Variables

**Docker environment variables** are key-value pairs that can be set within a Docker image or container to configure behavior without changing the application's code. These variables are particularly useful for managing configuration settings that differ between environments, such as development, testing, and production.

### Benefits:
- **Flexibility:** Quickly change settings without modifying the code or Docker images.
- **Security:** Keep sensitive information, like database passwords, out of the image and inject it at runtime.

## Benefits of Interpolation

**Interpolation** in the context of Docker environment variables allows you to dynamically insert values into your configuration. This is beneficial for creating more dynamic and flexible Docker configurations.

### Benefits:
- **Dynamic Configurations:** Easily adjust your applicationâ€™s behavior based on the environment without changing the code.
- **Code Reusability:** Write more generic code and scripts that adapt based on environment variables.
- **Security and Separation of Concerns:** Keep configuration data separate from code, making it easier to manage security and changes.

In summary, Docker images, containers, and environment variables are foundational concepts in Docker that enable the portability, consistency, and efficient scaling of applications. Interpolation of environment variables enhances the flexibility and security of Docker containers, making it easier to manage applications across different environments, including when deploying websites or services like Docusaurus.

## Docker Networks

Docker networks facilitate communication between Docker containers, allowing them to send data to each other or establish connections with external networks. Essentially, Docker networking plays a pivotal role in managing how containers interact both amongst themselves and with the wider world. This framework provides the necessary mechanisms to encapsulate container communication, ensuring that complex architectures can be simplified into more manageable, secure, and isolated systems.

### How Docker Networks Work

At its core, Docker abstracts the complexity of network management, allowing developers and administrators to focus on the high-level configuration rather than the intricacies of network implementation. When a Docker environment is set up, it automatically creates a default bridge network, which connects containers to the host, allowing them to communicate and transfer data. This default network provides a basic level of connectivity out of the box.

However, Dockerâ€™s networking capabilities extend far beyond this default setup. Docker allows for the creation of multiple network types, each tailored to specific needs and scenarios. This flexibility enables more complex and secure networking schemes, such as network isolation, where only selected containers can communicate with each other, or more open networks where containers can freely exchange information.

### Benefits of Docker Networks

#### DNS and Service Discovery

On user-defined networks, Dockerâ€™s built-in DNS server assigns DNS entries to each containerâ€™s name. This way, containers can resolve the names of other containers to their IP addresses, enabling them to communicate using friendly names rather than IP addresses, which can change and be hard to manage.

#### Simplified Container Communication
Docker networks simplify the process of establishing communication between containers. Containers on the same network can discover and communicate with each other using container names instead of relying on IP addresses, which can change if a container is restarted.

#### Network Isolation
Containers can be segmented into different networks, enhancing security by limiting which services can communicate with each other. This isolation is critical in multi-application or multi-service deployments, ensuring that only containers that need to communicate are allowed to do so.

#### Controlled External Access
Docker networks allow for fine-grained control over which containers can communicate with the outside world, enabling a secure environment where only specific entry points are available to external users or systems.

#### Enhanced Scalability and Flexibility
The ability to create custom networks tailored to specific requirements or docker-compose setups makes it easier to scale applications horizontally. Each service can be scaled independently within its network, and networks can be configured to match the specific needs of an application or environment.

### Network Instructions
#### expose:

- **Purpose**: The `expose` instruction is used to indicate that a container listens on specified network ports during runtime. However, it does not make these ports accessible from the host; it's more about documenting which ports are used for inter-container communication.
- **Visibility**: Exposed ports are only accessible to linked services within the same Docker network. They are not published to the host, making them invisible to the outside world, including the host machine.
- **Docker Compose Usage**: In a Docker Compose file, you use `expose` to list the ports that other services in the same Docker network can access.

```yaml
services:
  my-service:
    image: my-image
    expose:
      - "3000"
```

In this example, `my-service` will expose port `3000` to other containers on the same network but not to the host machine or outside world.

#### ports:

- **Purpose**: The `ports` instruction is used to map a container's ports to the host, effectively making a service running inside a container accessible from outside of Docker, including the internet (if allowed by firewall rules), or the local host.
- **Visibility**: Ports specified under `ports` are published to the host, making a service inside the container reachable from the host machine and potentially from other machines, depending on the network configuration and firewall settings.
- **Docker Compose Usage**: In a Docker Compose file, `ports` is used to define the port mapping from the host to the containers.

```yaml
services:
  my-service:
    image: my-image
    ports:
      - "4000:3000"
```

In this example, `my-service` maps port `3000` inside the container to port `4000` on the host machine. This means that traffic to the host's port `4000` is forwarded to port `3000` on the container.

#### Summary:

- **`expose`** is about container-to-container communication within the same Docker network and is a way of documenting which ports a container uses without opening them to the outside.
- **`ports`** actively maps and publishes a container's ports to the host, enabling external access to a service running inside a container.

Understanding the difference between these two is crucial for correctly configuring services in Docker and Docker Compose, especially regarding service accessibility, security, and network configuration.

### Types of Docker Networks and Use Cases

Docker supports several types of networks, each designed for specific scenarios. Hereâ€™s a breakdown:

#### Bridge Networks
- **Default Type:** Automatically created when you run a container without specifying a network.
- **Use Cases:** Ideal for standalone containers or groups of interconnected containers on the same Docker host. It's the most common network type, suitable for small to medium-scale applications that require communication between containers without the complexity of more sophisticated network topologies.

#### Host Networks
- **Direct Access:** Removes network isolation between the container and the Docker host, allowing the container to use the hostâ€™s networking directly.
- **Use Cases:** Useful for services that need to handle lots of traffic or low-latency applications. However, it exposes the container more directly to the external network, which may not be suitable for all applications.

#### Overlay Networks
- **Distributed Systems:** Supports multi-host networking, enabling containers running on different Docker hosts to communicate as if they were on the same host.
- **Use Cases:** Perfect for Dockerized applications running in a Swarm or Kubernetes cluster, facilitating communication across nodes in a cloud or data center environment. Itâ€™s essential for large-scale applications that require high availability and scalability across multiple servers.

#### Macvlan Networks
- **Physical Interface Emulation:** Makes it appear as if a container has its own physical device connected to the network.
- **Use Cases:** Ideal when migrating traditional applications that expect to be directly connected to the physical network, not virtualized. It's useful in scenarios where containers need a unique MAC address or direct access to an external network.

#### None Network
- **No Connectivity:** Provides a way to completely disable networking for a container.
- **Use Cases:** Useful for containers that should run isolated from the network and other containers, typically used for testing or security-sensitive applications that do not require network access to function.
### Network Examples
Defining networks in Docker Compose allows you to specify and configure custom networks for your containers to communicate on. Below are examples that illustrate how to define and use networks in a Docker Compose file.

#### Example 1: Simple Custom Network

This example demonstrates how to define a simple custom bridge network and assign containers to it.

```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      - my-network

  database:
    image: postgres:latest
    networks:
      - my-network

networks:
  my-network:
    driver: bridge
```

In this example, both the `app` and `database` services are connected to a custom network named `my-network`. This enables direct communication between the `app` service and the `database` service.

#### Example 2: Multiple Networks

This example shows how to define multiple networks to segregate traffic between services.

```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      - front-end
      - back-end
  
  web:
    image: nginx:alpine
    networks:
      - front-end

  database:
    image: mysql:latest
    networks:
      - back-end

networks:
  front-end:
    driver: bridge
  back-end:
    driver: bridge
```

Here, we have three services: `app`, `web`, and `database`. The `app` service is connected to two networks, `front-end` and `back-end`, allowing it to communicate with both the `web` and `database` services. However, the `web` service cannot directly communicate with the `database` service, as they are on separate networks.

#### Example 3: External Networks

Sometimes you might want to connect your services to an existing network outside of Docker Compose.

```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      - external-network

networks:
  external-network:
    external: true
```

In this Docker Compose file, `app` is connected to an external network named `external-network`. The `external: true` parameter indicates that this network is not managed by Docker Compose and must exist before running `docker-compose up`.

#### Example 4: Assigning Static IP Addresses

For scenarios requiring static IP addresses within your custom network, Docker Compose allows you to specify these as well.

```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      my-network:
        ipv4_address: 172.25.0.101
  
  database:
    image: postgres:latest
    networks:
      my-network:
        ipv4_address: 172.25.0.102

networks:
  my-network:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.25.0.0/24
```

In this configuration, both the `app` and `database` services are assigned static IP addresses within the `my-network` network. The `ipam` configuration specifies the subnet for the network, allowing Docker to manage IP address allocation within this range.

#### Example 5: No Internet Access (Isolation)

```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      - no-network

  database:
    image: postgres:latest
    networks:
      - no-network

networks:
  no-network:
    driver: none
```
In this example, both the `app` and `database` services are connected to a custom network named `no-network`. This uses network `driver: none` meaning that the containers using this network will not be able to communicate with any other containers or the host, Including eachother. The network interface is essentialy disabled so no IP addresses are assigned to the containers.

#### Example 6: macvlan
- **Description**: Allows you to assign a MAC address to a container, making it appear as a physical device on your network. The Docker hostâ€™s networking can be bypassed.
- **Use Case**: Useful if you require containers to have direct access to an existing network, behaving as though they were physically attached to it. Often used in scenarios where you need to integrate with legacy applications or systems that expect a direct network connection.
```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      - no-network

  database:
    image: postgres:latest
    networks:
      - no-network

networks:
  no-network:
    driver: macvlan
```

#### Example 7: overlay

- **Description**: Enables Docker Swarm services to communicate across multiple Docker hosts. It leverages network encapsulation to allow containers on different hosts to communicate as if they were on the same host.
- **Use Case**: Ideal for Docker Swarm deployments where you need to manage services that span multiple nodes in a cluster.
```yaml
name: example
services:
  app:
    image: my-app:image
    networks:
      - no-network

  database:
    image: postgres:latest
    networks:
      - no-network

networks:
  no-network:
    driver: overlay
```

#### Example 8: network_mode: host
Using `host` mode allows the container to share the host's network stack. Thus, the container does not get its own IP-address allocated, and it uses the host's IP and port space. Containers running in host mode offer the best network performance and are useful when a container needs to manage or observe the host's network stack.
```yaml
name: example
services:
  app:
    image: my-app:image
    network_mode: host

  database:
    image: postgres:latest
    network_mode: host
```

#### Example 9: network_mode: none
This mode disables all networking for the container. Essentially, it provides a container with its own network namespace but without a network interface set up within it. This mode is useful for containers that need to run processes in isolation without requiring network access.
```yaml
name: example
services:
  app:
    image: my-app:image
    network_mode: none

  database:
    image: postgres:latest
    network_mode: none
```

#### Example 10: network_mode: service:[service name]

This option allows a container to share the network stack of another container. By specifying the name of another service defined in the same `docker-compose.yml` file, the container inherits the networking configuration of the targeted service. This is useful for closely coupled services that need to share the network stack without being exposed to the wider network.
```yaml
name: example
services:
  app:
    image: my-app:image
    network_mode: "service:[service name]"

  database:
    image: postgres:latest
    network_mode: "service:[service name]"
```
#### Example 11: container:[container name/id]

Similar to the `service:` option, but instead of specifying a service name, you directly specify a container name or ID. The container using this mode will share the network namespace of the target container, allowing it to use the exact network configurations, including the IP address.
```yaml
name: example
services:
  app:
    image: my-app:image
    network_mode: "container:[container name/id]"

  database:
    image: postgres:latest
    network_mode: "container:[container name/id]"
```

These examples demonstrate the flexibility of Docker Compose in defining and using networks, enabling complex networking setups to be described in a straightforward and declarative manner.

## Docker Storage
Docker offers various storage options to manage the data generated by and used by containers. These storage solutions cater to different requirements for persistence, scalability, sharing among containers, and data backup. Here are the primary Docker storage options, detailing their benefits, use cases, and Docker Compose examples for each.

### Volumes

**Benefits:**
- Volumes are stored in a part of the host filesystem which is managed by Docker (`/var/lib/docker/volumes/` on Linux). They are the preferred mechanism for persisting data generated by and used by Docker containers.
- Completely managed by Docker, independent of the container's lifecycle, meaning data persists even if a container is deleted.
- Supports sharing among multiple containers and services.

**Use Cases:**
- Persisting database storage, ensuring data survival across container rebuilds.
- Sharing configuration files between the host and containers or among multiple containers.

**Example:**
```yaml
name: example
services:
  db:
    image: postgres:latest
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:
```

### Bind Mounts

**Benefits:**
- Bind mounts can be stored anywhere on the host system. They allow for the storage and management of files or directories on the host system.
- Provide more control over the filesystem as they bypass Docker's management of the volume and allow for the direct inclusion of local host paths.
- Useful for development purposes where code on the host needs to be tested in a container environment in real-time.

**Use Cases:**
- Live reloading during development, where code changes on the host need to be immediately reflected in the container.
- Providing access to sensitive configurations that should not be included in images.

**Example:**
```yaml
name: example
services:
  app:
    image: my-nodejs-app
    volumes:
      - type: bind
        source: ./my-app
        target: /usr/src/app
```

### tmpfs Mounts

**Benefits:**
- Mounted directly in the host systemâ€™s memory (or swap, depending on system configuration), tmpfs mounts never touch the physical disk. This results in faster read and write times compared to volumes and bind mounts.
- Data stored in a tmpfs mount is temporary and is cleared when the container is stopped, which can be beneficial for sensitive data or cache.

**Use Cases:**
- Storing cache data or session information that needs quick access but does not need to persist after the container stops.
- Handling sensitive information which should not be written to disk to avoid data leakage.

**Example:**
```yaml
name: example
services:
  cache:
    image: redis:alpine
    tmpfs:
      - /data
```
In Docker Compose, adjusting the size of `tmpfs` mounts along with adding other arguments provides you control over the temporary filesystems associated with your services. This allows for optimizing performance and security for containers that need fast, ephemeral storage. Below is an explanation of how to change the `tmpfs` size and include other options in Docker Compose.
:::warning
tmpfs uses memory (RAM) adjust the size as needed. Monitor how much RAM the mount utilizes
:::

#### Changing the `tmpfs` Size

To specify the size of a `tmpfs` mount, you can use the `size` option. The size is set in bytes but can also be expressed in a human-readable manner using units like `k`, `m`, or `g` for kilobytes, megabytes, or gigabytes, respectively.

#### Additional `tmpfs` Options

Apart from setting the size, Docker allows configuring additional parameters for `tmpfs` mounts including:

- **`mode`**: Sets the file mode (permissions) in an octal format. For example, a mode of `700` would restrict access to the owner of the file only.
- **`uid` and `gid`**: Specify the user ID and group ID for the mount, allowing you to control which user or group owns the `tmpfs` mount.

#### Docker Compose Example with `tmpfs` Options

Here's how you can configure a service with a `tmpfs` mount, including changing its size and setting other options in a Docker Compose file:

```yaml
name: example
services:
  my-service:
    image: my-image
    volumes:
      - type: tmpfs
        target: /app/tmp
        tmpfs:
          size: 100000000 # 100 MB
          mode: 1777
          uid: 1000 # User ID
          gid: 1000 # Group ID
```

#### Explanation:

- **`type: tmpfs`**: Specifies the volume type as tmpfs.
- **`target`**: Defines the container path where the tmpfs mount will be located on the containers filesystem.
- **`tmpfs:size`**: Allocates 100MB of space for the tmpfs mount. Adjust the value as needed for your application requirements.
- **`tmpfs:mode`**: Sets the permissions for the tmpfs mount to `1777`, which is similar to the `tmp` directory on UNIX systems, allowing all users to create files but preventing them from deleting or modifying files owned by others.
- **`tmpfs:uid`** and **`tmpfs:gid`**: These options set the ownership of the tmpfs mount. You may need to adjust these values based on your container's user configuration to ensure proper access to the tmpfs mount.

This configuration demonstrates how to effectively use `tmpfs` mounts for temporary storage needs within your Docker containers, optimizing for both performance and security by controlling the size, permissions, and ownership of the tmpfs mount.

### Named Pipes or FIFO

**Benefits:**
- Allows for one-way data flow between the container and the host or between containers. This can be beneficial for processing data streams.
- Limits data to being in transit, not stored, which can be advantageous for streaming data.

**Use Cases:**
- Real-time event processing where data is consumed by a container, processed, and passed on without the need for persistence.
- Logs or metrics collection where data is streamed from the container to a host service for processing or analysis.

**Example:** Docker Compose does not directly support named pipes in its syntax, but you can create them on the host and use them within containers through bind mounts.

These storage options allow Docker to support a wide range of applications, from temporary data processing to persistent data storage, offering flexibility in how data is managed within and across containers.

## Conclusion

Docker has revolutionized how developers build, deploy, and manage applications. By leveraging Docker, teams can focus on building great software without worrying about inconsistencies between development and production environments. Whether you're developing complex applications, deploying microservices, or automating your development pipeline, Docker provides the tools and flexibility needed to streamline these processes.

## Resources:
[Docker Networking Overview](https://docs.docker.com/engine/network/)\
[Docker Storage](https://docs.docker.com/engine/storage/)

<a href="https://www.buymeacoffee.com/BankaiTech"><img src="https://img.buymeacoffee.com/button-api/?text=Buy me a beer&emoji=ðŸº&slug=BankaiTech&button_colour=FFDD00&font_colour=000000&font_family=Cookie&outline_colour=000000&coffee_colour=ffffff" /></a>
